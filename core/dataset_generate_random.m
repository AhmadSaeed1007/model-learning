function Tests = dataset_generate_random(model,Ntests,optGen)

    % Generates a collection of tests, by solving 'model' for 'Ntests'
    % randomly generated inputs. Optionally, it stores the results in the 
    % file opt.outFile.

    fprintf('generating random tests...\n')
    optGen.dummy = 0;
    
    if ~isfield(optGen,'do_save')
        optGen.do_save = 0;
    end
    if ~isfield(optGen,'freq_save')
        optGen.freq_save = 10;
    end
    if ~isfield(optGen,'outFile')
        optGen.outFile = '';
    end
    if ~isfield(optGen,'T')
        optGen.T = model.problem.T;
    end
    if ~isfield(optGen,'dt')
        optGen.dt = model.dt;
    end
    if ~isfield(optGen,'do_plot')
        optGen.do_plot = 0;
    end
    if ~isfield(optGen,'pause_eachtest')
        optGen.pause_eachtest = 0;
    end
    if ~isfield(optGen,'save_x')
        optGen.save_x = 0;
    end
    if ~isfield(optGen,'append')
        optGen.append = 0;
    end
    if ~isfield(optGen,'save_x_dt')
        optGen.save_x_dt = optGen.dt;
    end
    if ~isfield(optGen,'constant')
        optGen.constant = 0;
    end
    if ~isfield(optGen,'lhs') 
        optGen.lhs = 0; % if true, constants sampes are generated by Latine Hypercube Sampling
    end
    if ~isfield(optGen,'wait_init')
        optGen.wait_init = 0;
    end
    if ~isfield(optGen,'wait_init_time_wait')
        optGen.wait_init_time_wait = optGen.T/10;
    end
    if ~isfield(optGen,'wait_init_time_raise')
        optGen.wait_init_time_raise = optGen.T/10;
    end
    if ~isfield(optGen,'closed_loop')
        optGen.closed_loop = 0;
    end
    if ~isfield(optGen,'closed_loop_toll_x')
        optGen.closed_loop_toll_x = 1e-1;
    end
    if ~isfield(optGen,'closed_loop_toll_y')
        optGen.closed_loop_toll_y = 1e-2;
    end
    if ~isfield(optGen,'closed_loop_timerelax')
        optGen.closed_loop_timerelax = optGen.T/10;
    end
    if ~isfield(optGen,'closed_loop_timerest')
        optGen.closed_loop_timerest = 2*optGen.T/10;
    end
    if ~isfield(optGen,'u_min')
        optGen.u_min = model.problem.u_min;
    end
    if ~isfield(optGen,'u_max')
        optGen.u_max = model.problem.u_max;
    end
    
    %% Setting options
    testsOffset = 0;
    optSolve.verbose = 1;
    
    if optGen.save_x || optGen.closed_loop
        optSolve.save_x = 1;
        optSolve.save_x_freq = optGen.save_x_dt / optGen.dt;
    end
    
    if optGen.do_save 
        baseopt = get_base_options();
        filename = [baseopt.BaseDir '/' model.problem.dir_data '/' optGen.outFile];
        
        if isfield(optGen,'append')
            if optGen.append && exist(filename, 'file') == 2                
                existingTests = load(filename);
                Tests = existingTests.Tests;
                testsOffset = length(Tests);
            end
        end
    end
    
    if optGen.do_plot
        figure()
        optSolve.do_plot = 1;
    end
        
    %% Initialization
    tt = 0:optGen.dt:optGen.T;
    %nT = length(tt);
    
    if model.problem.metaproblem && ~model.problem.particularized
        particularization = 1;
    else
        particularization = 0;
        mod_part = model;
    end
        
    if model.problem.nU > 0 && optGen.constant && optGen.lhs
        u_const_lhs = lhsdesign(Ntests,model.problem.nU)';
    end
    
    %% Tests execution
    iTest = 1;
    while iTest <= Ntests
        
        fprintf('sample %d of %d...\n',iTest,Ntests)
        iTestCurr = iTest+testsOffset;
        Tests{iTestCurr}.tt = tt;
        %optGen.optRandomU.do_plot = 1;
        
        %% input generation
        if model.problem.nU > 0
                      
            if optGen.constant     
                if optGen.lhs
                    u_const_adim = u_const_lhs(:,iTest);
                else
                    u_const_adim = rand(model.problem.nU,1);
                end  
                u_const = optGen.u_min + (optGen.u_max - optGen.u_min).*u_const_adim;
                Tests{iTestCurr}.uu = repmat(u_const,1,length(tt));
            else
                optGen.optRandomU.dim = model.problem.nU;
                optGen.optRandomU.umin = optGen.u_min;
                optGen.optRandomU.umax = optGen.u_max;
                Tests{iTestCurr}.uu = get_random_time_course(tt,optGen.optRandomU);
            end
            
            optGen.wait_init_time_wait = optGen.wait_init_time_wait.*ones(model.problem.nU,1);
            optGen.wait_init_time_raise = optGen.wait_init_time_raise.*ones(model.problem.nU,1);
            optGen.closed_loop_timerest = optGen.closed_loop_timerest.*ones(model.problem.nU,1);
            optGen.closed_loop_timerelax = optGen.closed_loop_timerelax.*ones(model.problem.nU,1);

            if optGen.wait_init
                T1 = optGen.wait_init_time_wait;
                T2 = optGen.wait_init_time_wait + optGen.wait_init_time_raise;
                for iU = 1:model.problem.nU
                    if optGen.wait_init_time_raise(iU) == 0
                        relax_shape(iU,:) = double(tt>T2(iU));
                    else
                        relax_shape(iU,:) = (tt>T1(iU)).*(tt<=T2(iU)).*(.5*(1+cos(pi*(T2(iU)-tt)./optGen.wait_init_time_raise(iU)))) + (tt>T2(iU));
                    end
                end
                Tests{iTestCurr}.uu = model.problem.u_ref + ( Tests{iTestCurr}.uu - model.problem.u_ref ) .* relax_shape;
            end

            if optGen.closed_loop
                T1 = optGen.T - optGen.closed_loop_timerest - optGen.closed_loop_timerelax;
                T2 = optGen.T - optGen.closed_loop_timerest;
                for iU = 1:model.problem.nU
                    if optGen.closed_loop_timerelax(iU,:) == 0
                        relax_shape(iU,:) = double(tt<=T1(iU,:));
                    else
                        relax_shape(iU,:) = (tt<=T1(iU,:)) + (tt>T1(iU,:)).*(tt<=T2(iU,:)).*(.5*(1+cos(pi*(tt-T1(iU,:))./optGen.closed_loop_timerelax(iU,:))));
                    end
                end
                Tests{iTestCurr}.uu = model.problem.u_ref + ( Tests{iTestCurr}.uu - model.problem.u_ref ) .* relax_shape;
            end
        end
        
        %% Particularization (if needed)
        if particularization
            mod_part = metamodel_particularize(model);
        end
        
        %% Model solution
        output = model_solve(Tests{iTestCurr},mod_part,optSolve);
        
        %% closed loop check
        accept = 1;
        if optGen.closed_loop
%             xnorm_max    = max(sqrt(sum(output.xx.^2,1)));
%             xnorm_errend = sqrt(sum(( output.xx(:,end) - model.x0 ).^2));
            if isfield(model.problem,'y_ref')
                y_ref = model.problem.y_ref;
            else
                y_ref = output.yy(:,1);
            end
            if isfield(output,'xx')
                xnorm_max    = max(max(abs(output.xx)));
                xnorm_errend = max(abs(output.xx(:,end) - model.x0));
                xerrend_normalized = xnorm_errend/xnorm_max;
            else
                xerrend_normalized = 0;
            end
            ynorm_max    = max(max(abs(output.yy)));
            ynorm_errend = max(abs(output.yy(:,end) - y_ref));
            yerrend_normalized = ynorm_errend/ynorm_max;
            if  xerrend_normalized > optGen.closed_loop_toll_x || yerrend_normalized > optGen.closed_loop_toll_y
                accept = 0;
                fprintf('   ---------------------------------------------------- test rejected!\n');
            else
                %fprintf('   accepted!');
            end
            fprintf('   normalized end error (x): %1.2e\n',xerrend_normalized)
            fprintf('   normalized end error (y): %1.2e\n',yerrend_normalized)
        end
        
        %% output update
        if accept
%             Tests{iTestCurr}.yy = output.yy;
%             if optGen.save_x       
%                 Tests{iTestCurr}.xx = output.xx;
%             end
            Tests{iTestCurr} = output;
            if particularization
                if ~model.problem.fixed_x0
                    Tests{iTestCurr}.x0 = mod_part.x0;
                end
                if model.problem.samples_variability
                    Tests{iTestCurr}.alpha = mod_part.alpha;
                end
            end
        end
        
        %% plotting
        if optGen.do_plot
%             subplot(2,1,1)
%             plot(tt,Tests{iTestCurr}.uu,'-','linewidth',1)
%             axis([0 optGen.T min(model.problem.u_min) max(model.problem.u_max)])
%             subplot(2,1,2)
%             plot(tt,output.yy,'-','linewidth',1)
%             axis([0 optGen.T min(model.problem.y_min) max(model.problem.y_max)])
            if optGen.pause_eachtest && iTest < Ntests
                pause()
%             else
%                 pause(1e-16)
            end
        end
        
        %% saving
        if optGen.do_save && ( mod(iTest,optGen.freq_save)==0 || iTest == Ntests )
            save(filename,'Tests');
        end
                
        if accept
            iTest = iTest + 1;
        end
    
    end
    
    fprintf('Finished generating random tests!\n')
        
end